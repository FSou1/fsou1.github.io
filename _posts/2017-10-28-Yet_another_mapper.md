---
layout: post
title: Пишем свой маппер для .NET Standard 2.0 
---

В сегодняшней заметке я хотел бы поведать вам о коротком приключении написания своего маппера для .NET Standard 2.0. Ссылка на github и результаты benchmark'ов в конце.

Думаю ни для кого из вас не секрет, что такое mapper и для чего он нужен. Буквально на каждом шагу в процессе работы мы сталкиваемся с теми или иными примерами маппингов (или трансформаций) данных из одного вида в другой. К ним можно отнести маппинг данных из хранилища в domain model, маппинг данных response удалённого сервиса в view model и уже затем в domain model и т.д. Зачастую, на границе каждого уровня абстракции существуют входной и выходной форматы данных и именно в моменты взаимодействия абстракций такая вещь, как маппер, может показать себя во всей красе, привнося с собой существенную экономию времени и effort'ов для разработчика и, как следствие, забирая на себя долю от общей производительности системы. 

Исходя из этого можно описать и MVP требования:

1. Скорость работы (less performance & memory impact);
2. Простота использования (clean & easy to use API).

Что касается первого пункта, то в этом нам поможет BenchmarkDotNet и вдумчивая реализация, не лишённая и оптимизаций. Для второго же я написал простой unit test, который, в некотором роде, выступает документаций API нашего маппера:

```c#
[TestMethod]
public void WhenMappingExist_Then_Map()
{
    var dto = new CustomerDto
    {
        Id = 42,
        Title = "Test",
        CreatedAtUtc = new DateTime(2017, 9, 3),
        IsDeleted = true
    };

    mapper.Register<CustomerDto, Customer>();

    var customer = mapper.Map<CustomerDto, Customer>(dto);

    Assert.AreEqual(42, customer.Id);
    Assert.AreEqual("Test", customer.Title);
    Assert.AreEqual(new DateTime(2017, 9, 3), customer.CreatedAtUtc);
    Assert.AreEqual(true, customer.IsDeleted);
}
```

Итого, нам потребуется реализовать лишь 2 простых метода: 

1. `void Register<TSource, TDest>()`;
2. `TDest Map<TSource, TDest>(TSource source)`.

## Регистрация

На самом деле сам процесс регистрации может осуществляться и при первом вызове метода `Map`, тем самым став лишним. Однако, я вынес его отдельно для по следующим причинам:

1. Для верификации- в случае отсутствия конструктора по умолчанию (или невозможности осуществить маппинг итогового типа) на мой взгляд, сообщить об этом следует как можно раньше на этапе конфигурации, соблюдая тем самым принцип Fail fast. В противном случае ошибка невозможности создания экземпляра типа может настигнуть нас уже на этапе выполнения инфраструктурного кода или бизнес-логики;
2. Для расширения- на данный момент API предельно прост и under the hood подразумевает маппинг опираясь на naming conventions, однако, вполне вероятно что уже очень скоро мы захотим вводить правила осуществления маппинга тех или иных полей, значением для присваивания в которые может и вовсе явиться результат выполнения метода. В этом случае, дабы так же соблюсти и принцип Single responsible, такое разделение мне кажется вполне закономерным.

Если метод `Map` в любом маппере является основным и именно на него приходится львиная доля времени выполнения, то метод `Register` наоборот, для каждой пары типов будет вызывается лишь единожды на этапе конфигурации. Именно поэтому он является отличным кандидатом для совершения всех необходимых "тяжеловесных" манипуляций для генерации оптимального плана выполнения маппинга и как следствие, дальнейшего кеширования полученных результатов.

Таким образом его реализация должна включать:

1. Построение плана выполнения создания и инициализации экземпляра требуемого типа;
2. Кеширование результатов.



## Маппинг

Внутренняя реализация метода `Map` должна быть предельно проста и оптимизирована ввиду того, что именно этот метод будет вызываться в 99.9% случаев. Поэтому всё, что нам необходимо сделать, это максимально быстро найти ссылку на скомпилированный ранее `Delegate` в кеше и вернуть результат его выполнения:

```c#
public TDest Map<TSource, TDest>(TSource source)
{
    var key = new TypeTuple(typeof(TSource), typeof(TDest));
    var activator = GetMap(key);
    return ((Func<TSource, TDest>)activator)(source);
}
```

## Результаты

В качестве результатов хотелось бы привести итоги финальных замеров существующих (и находящихся в актуальном состоянии) на данный момент мапперов:

``` ini

BenchmarkDotNet=v0.10.9, OS=Windows 8.1 (6.3.9600)
Processor=Intel Core i5-5200U CPU 2.20GHz (Broadwell), ProcessorCount=4
Frequency=2143473 Hz, Resolution=466.5326 ns, Timer=TSC
.NET Core SDK=2.0.0
  [Host]     : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT
  DefaultJob : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT


```
 |                 Method |       Mean |     Error |    StdDev |
 |----------------------- |-----------:|----------:|----------:|
 |      FsMapperBenchmark |  95.929 ns | 1.3622 ns | 1.1375 ns |
 | ExpressMapperBenchmark | 237.110 ns | 1.4847 ns | 1.3888 ns |
 |    AutoMapperBenchmark | 196.640 ns | 4.6218 ns | 5.5019 ns |
 |       MapsterBenchmark |  85.906 ns | 0.3268 ns | 0.2897 ns |
 |   AgileMapperBenchmark | 212.976 ns | 1.0561 ns | 0.8246 ns |
 |    CtorMapperBenchmark |   7.202 ns | 0.0832 ns | 0.0737 ns |

Исходный код проекта доступен на github: [https://github.com/FSou1/FsMapper](https://github.com/FSou1/FsMapper).

Спасибо что дочитали до конца и надеюсь эта заметка была вам полезна. Пишите в комментариях, а что на ваш взгляд ещё можно было бы оптимизировать.
