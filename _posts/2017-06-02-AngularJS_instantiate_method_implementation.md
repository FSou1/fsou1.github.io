---
layout: post
title: Об одной интересной конструкции в $injector.instantiate
---

Задумывались ли вы когда-нибудь, как создаются экземпляры используемых вами типов angularJS? Контроллеры, фабрики, сервисы, декораторы, значения- буквально каждый из них в конце концов передаётся на исполнение в функцию [instantiate](https://github.com/angular/angular.js/blob/master/src/auto/injector.js#L906) класса $injector, где их поджидает довольно занимательная конструкция, о которой сегодня и хотелось бы поговорить.

А речь сегодня пойдёт о следующей строке:

```javascript
return new (Function.prototype.bind.apply(ctor, args))();
```

Очевидно ли для вас сходу принцип её действия? Если ответ положительный, то благодарю за внимание и уделённое вами время :)

Теперь же, когда все съевшие собаку на javascript читатели нас покинули, хотел бы ответить на собственный вопрос: впервые увидев эту строку, я растерялся и абсолютно ничего не понял во всех этих взаимоотношениях и хитросплетениях функций bind, apply, new и (). Давайте разбираться и начать это делать я предлагаю от обратного, а именно: пускай у нас есть некий параметризованный класс, экземпляр которого мы и хотим создать:

```javascript
function Animal(name, sound) {
  this.name = name;
  this.sound = sound;
}
```

## new

Что может быть проще скажете вы и будете правы: `var dog = new Animal('Dog', 'Woof!');`. Оператор `new` это первое что нам потребуется, чтобы получить экземпляр класса Animal. Небольшое отступление о том, как работает new:

> Когда исполняется new Foo(...) , происходит следующее:
> 
> 1. Создается новый объект, наследующий Foo.prototype.
> 2. Вызывается конструктор — функция Foo с указанными аргументами и this, привязанным к только что созданному объекту. new Foo эквивалентно new Foo(), то есть если аргументы не указаны, Foo вызывается без аргументов.
> 3. Результатом выражения new становится объект, возвращенный конструктором. Если конструктор не возвращет объект явно, используется объект из п. 1. (Обычно конструкторы не возвращают значение, но они могут делать это, если нужно переопределить обычный процесс создания объектов.)
>
> Подробнее: [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new)

Отлично, теперь давайте обернём наш способ создания класса Animal в функцию, чтобы код инициализации был общим для всех требуемых вызовов:

```javascript
function CreateAnimal(name, sound) {
    return new Animal(name, sound);
}
```

Отлично, двигаемся дальше. Со временем мы начинаем хотеть создавать животных разного типа, а не только лишь Animal, а значит, у нас есть 2 варианта:

1. Реализовать фабрику, которая в зависимости от требуемого нам типа будет сама создавать необходимый экземпляр;
2. Передавать функцию конструктора в качестве параметра и на её основе создавать новую с уже привязанными к ней передаваемыми аргументами (с чем нам прекрасно помогает функция `bind`).

И в случае с $injector.instantiate был выбран второй путь:

## bind

```javascript
function Create(ctorFunc, name, sound) {
    return new (ctorFunc.bind(null, name, sound));
}

console.log( Create(Animal, 'dog', 'woof') );
```

Небольшое отступление о том, как работает bind:

> Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.
>
> Подробнее: [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)

В нашем случае в качестве контекста мы передаем null, т.к. планируем использовать новую созданную с помощью bind функцию с оператором new, который игнорирует this и создает для него пустой объект. Результатом выполнения функции bind в нашем случае послужит новая функция с уже привязанными к ней аргументами (т.е. `return new fn;`, где fn- результат вызова bind).

Отлично, теперь мы можем использовать нашу функцию, чтобы создавать любых животных, конструкторы которых.. принимают параметры `name` и `sound`. А как же рыбы или божьи коровки скажете вы и будете правы- назревают 2 проблемы:

1. Аргументы конструкторов наших классов могут начать меняться (например порядок или их кол-во), а значит вносить изменения нам потребуется сразу в нескольких местах,- в сигнатуры конструкторов, в строки вызова функции Create и в строку создания экземпляра `return new (ctorFunc.bind(null, name, sound ))`;
2. Чем больше у нас появляется классов (конструкторов животных), тем выше вероятность того, что аргументы для их создания нам потребуются разные и мы уже не сможем использовать единую функцию создания (или же нам придётся перечислять все из них, а заполнять лишь требуемые).

## apply

Решением этих проблем может стать сквозная передача аргументов из функции создания прямиком в конструктор, другими словами- универсальная функция, принимающая конструктор и необходимый массив аргументов и возвращающая новую функцию, к которой эти аргументы привязаны. Для этого в javascript есть замечательная функция `apply` (или её аналог `call`, если кол-во аргументов известно заранее).

Небольшое отступление о том, как работает apply:

> Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта).
> Хотя синтаксис этой функции практически полностью идентичен функции call(), фундаментальное различие между ними заключается в том, что функция call() принимает список аргументов, в то время, как функция apply() принимает единичный массив аргументов.
>
> [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)

Здесь начинается пожалуй самая сложная часть, т.к. нам предстоит вызвать функцию bind, контекстом которой является конструктор (аналогично `ctorFunc.bind`, но только теперь, он передается первым аргументом apply) и в качестве аргументов использовать массив параметров конструктора.

В первом приближении должно получиться следующее: `bind.apply(ctorFunc, args)`, что преобразуется в `ctorFunc.bind(args[0], args[1], ..)`. Памятуя о том, что на месте args[0] является контекст функции `ctorFunc`, нам потребуется произвести смещение всех параметров на одну позицию, установив в этом элементе null: `args.unshift(null)`.

Функция bind недоступна в контексте выполнения Create, т.к. им является объект window, зато доступна посредством прототипа функции `Function.prototype`. Итоговым результатом станет следующая универсальная функция:

```javascript
function Create(ctorFunc, args) {
  args.unshift(null);
  return new (Function.prototype.bind.apply(ctorFunc, args ));
}

console.log( Create(Animal, ['dog', 'woof']) );
```

Возвращаясь к angularJS, в качестве Animal выступают конструкторы, например фабрик, а в качестве массива аргументов `['dog', 'woof']` выступают найденные (разрезолвленные) по имени зависимости:

```javascript
angular
    .module('app')
    .factory(function($scope) {
        // constructor
    }) 
```

или

```javascript
angular
    .module('app')
    .factory(['$scope', function($scope) { 
        // constructor 
    }
]) 
``` 

Всё что остаётся сделать для реализации полноценного метода $injector.instantiate, так это найти функцию конструктора и получить необходимые аргументы и можно создавать :)